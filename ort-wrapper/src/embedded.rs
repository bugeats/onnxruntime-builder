//! Embedded CUDA Libraries Module
//!
//! This module handles embedding, extracting, and loading CUDA shared libraries
//! that are compiled into the binary. This enables truly self-contained binaries
//! that work on any Linux system with an NVIDIA driver installed.
//!
//! # Architecture
//!
//! 1. **Build time**: The build.rs generates code that uses `include_bytes!` to
//!    embed the .so files directly into the binary.
//!
//! 2. **Runtime**: When CUDA is requested, we:
//!    - Extract the embedded .so files to a temporary directory
//!    - Set up LD_LIBRARY_PATH to include that directory
//!    - The CUDA provider then loads the libraries via dlopen
//!
//! # Size Considerations
//!
//! The full CUDA library bundle is ~2.7GB. To manage this:
//! - Libraries can be gzip compressed before embedding
//! - Only essential libraries are embedded by default
//! - The extraction is lazy (only when CUDA is actually used)

use std::path::Path;

// These imports are only used when dyn-embedded feature is enabled
#[cfg(feature = "dyn-embedded")]
use std::fs::{self, File};
#[cfg(feature = "dyn-embedded")]
use std::io::{self, Write};
#[cfg(feature = "dyn-embedded")]
use std::path::PathBuf;
#[cfg(feature = "dyn-embedded")]
use std::sync::Once;
#[cfg(feature = "dyn-embedded")]
use tracing::{debug, info, instrument, warn};

#[cfg(feature = "dyn-embedded")]
use flate2::read::GzDecoder;
#[cfg(feature = "dyn-embedded")]
use std::io::Read;

/// Information about an embedded library
#[derive(Debug, Clone)]
pub struct EmbeddedLib {
    /// Library filename (e.g., "libcudnn.so.9")
    pub name: &'static str,
    /// Compressed data (gzip)
    pub data: &'static [u8],
    /// Whether the data is gzip compressed
    pub compressed: bool,
}

// The actual embedded library data will be generated by build.rs
// and included here via include! macro
#[cfg(feature = "dyn-embedded")]
include!(concat!(env!("OUT_DIR"), "/embedded_libs.rs"));

// State for the extracted libraries (only used when dyn-embedded is enabled)
#[cfg(feature = "dyn-embedded")]
mod state {
    use std::path::PathBuf;
    use std::sync::Once;

    pub static EXTRACT_ONCE: Once = Once::new();
    pub static mut EXTRACTED_PATH: Option<PathBuf> = None;
}

/// Extract embedded libraries to a temporary directory.
///
/// This function is idempotent - calling it multiple times returns the same path.
/// The temporary directory is NOT automatically cleaned up (the OS will clean /tmp).
///
/// # Returns
///
/// Path to the directory containing the extracted .so files.
///
/// # Panics
///
/// Panics if extraction fails (disk full, permissions, etc.)
#[cfg(feature = "dyn-embedded")]
#[instrument(level = "info")]
pub fn extract_embedded_libs() -> &'static Path {
    unsafe {
        state::EXTRACT_ONCE.call_once(|| {
            info!("Extracting embedded CUDA libraries...");
            let path = do_extract().expect("Failed to extract embedded CUDA libraries");
            state::EXTRACTED_PATH = Some(path);
        });
        state::EXTRACTED_PATH.as_ref().unwrap()
    }
}

#[cfg(feature = "dyn-embedded")]
fn do_extract() -> io::Result<PathBuf> {
    // Create a unique temporary directory
    let temp_dir = std::env::temp_dir().join(format!(
        "onnxruntime-cuda-{}",
        std::process::id()
    ));

    fs::create_dir_all(&temp_dir)?;
    info!(path = ?temp_dir, "Created temp directory for CUDA libs");

    let libs = get_embedded_libs();
    let total_libs = libs.len();

    for (i, lib) in libs.iter().enumerate() {
        let dest_path = temp_dir.join(lib.name);
        debug!(
            lib = lib.name,
            compressed = lib.compressed,
            size = lib.data.len(),
            progress = format!("{}/{}", i + 1, total_libs),
            "Extracting library"
        );

        let mut file = File::create(&dest_path)?;

        if lib.compressed {
            // Decompress gzip data
            let mut decoder = GzDecoder::new(lib.data);
            let mut decompressed = Vec::new();
            decoder.read_to_end(&mut decompressed)?;
            file.write_all(&decompressed)?;
        } else {
            // Write raw data
            file.write_all(lib.data)?;
        }

        // Make executable
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&dest_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&dest_path, perms)?;
        }
    }

    info!(
        path = ?temp_dir,
        count = total_libs,
        "Extracted all embedded CUDA libraries"
    );

    Ok(temp_dir)
}

/// Get the list of embedded libraries
#[cfg(feature = "dyn-embedded")]
pub fn get_embedded_libs() -> &'static [EmbeddedLib] {
    &EMBEDDED_LIBS
}

/// Check if embedded CUDA libraries are available
#[cfg(feature = "dyn-embedded")]
pub fn has_embedded_cuda() -> bool {
    !EMBEDDED_LIBS.is_empty()
}

#[cfg(not(feature = "dyn-embedded"))]
pub fn has_embedded_cuda() -> bool {
    false
}

/// Set up the environment for CUDA library loading.
///
/// This extracts the embedded libraries (if not already done) and sets
/// LD_LIBRARY_PATH to include them.
///
/// # Returns
///
/// The path to the extracted libraries directory.
#[cfg(feature = "dyn-embedded")]
#[instrument(level = "info")]
pub fn setup_cuda_environment() -> &'static Path {
    let lib_path = extract_embedded_libs();

    // Prepend to LD_LIBRARY_PATH
    let current = std::env::var("LD_LIBRARY_PATH").unwrap_or_default();
    let new_path = if current.is_empty() {
        lib_path.to_string_lossy().to_string()
    } else {
        format!("{}:{}", lib_path.display(), current)
    };

    std::env::set_var("LD_LIBRARY_PATH", &new_path);
    debug!(ld_library_path = %new_path, "Updated LD_LIBRARY_PATH");

    lib_path
}

#[cfg(not(feature = "dyn-embedded"))]
pub fn setup_cuda_environment() -> &'static Path {
    panic!("dyn-embedded feature not enabled - cannot setup CUDA environment");
}

/// Clean up extracted libraries.
///
/// This removes the temporary directory containing extracted libraries.
/// Should be called on application exit if you want to clean up.
#[cfg(feature = "dyn-embedded")]
pub fn cleanup_extracted_libs() {
    unsafe {
        if let Some(ref path) = state::EXTRACTED_PATH {
            if path.exists() {
                if let Err(e) = fs::remove_dir_all(path) {
                    warn!(path = ?path, error = %e, "Failed to clean up extracted CUDA libs");
                } else {
                    info!(path = ?path, "Cleaned up extracted CUDA libs");
                }
            }
        }
    }
}

#[cfg(not(feature = "dyn-embedded"))]
pub fn cleanup_extracted_libs() {
    // No-op when feature not enabled
}

#[cfg(test)]
mod tests {
    #[test]
    #[cfg(feature = "dyn-embedded")]
    fn test_has_embedded_cuda() {
        use super::has_embedded_cuda;
        // This will be true if the build included embedded libs
        let has_cuda = has_embedded_cuda();
        println!("Has embedded CUDA: {}", has_cuda);
    }

    #[test]
    fn test_has_embedded_cuda_stub() {
        // When dyn-embedded is not enabled, this should return false
        #[cfg(not(feature = "dyn-embedded"))]
        {
            use super::has_embedded_cuda;
            assert!(!has_embedded_cuda());
        }
    }
}
